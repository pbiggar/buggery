* Write buggery tutorial, reference and FAQ.

* Search up the hierarchy to find the first buggery file

* Keep processing buggery files as you go up the hierarchy?

* A -k flag to keep going after errors (after parsing).

* Allow calling python functions.

* Define what operations result in what type

* Pattern matching instead of conditionals

* Checkpointing for lazy processing and saving time. Perhaps make notes of functions which can be checkpointed.

* Parallel processing. Wrap them in {}. Maybe go serial again after <>

* Turn the line parser into a real parser. This will mean # doesnt just break things, at the very least.

* Give an error for X=st1,st2

* Deal nicely with wanting access to procid, exit code, stderr, not just stdout

* I think the parsing strategy is to be very lenient and to get it all in the AST.

* Allow cleanup. A nice syntax might be to indent more, and if an inner thing fails, then we can clean it up on the way out.
