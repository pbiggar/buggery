#!/usr/bin/env python

import string
import pprint
import sys
import os
import glob
import re
from optparse import OptionParser # use optparse rather than argparse since it's portable between versions, not just 2.7 and beyond.


class Error(Exception):
  pass

class WhatToDo(Exception):
  pass




try:
  import ply.lex as lex
  import ply.yacc as yacc
except ImportError:
  sys.exit("""PLY (Python Lex-Yacc) library required.

  On ubuntu:
    $ apt-get install python-ply

  Otherwise, download and install from http://www.dabeaz.com/ply/
""")


class Parser(object):
  """Generate a nice AST to use later. We can implement the rule running as an AST walker.
  Here are the productions, ignoring syntactic tokens:

    # File
    file := task*

    # Task declarations
    task := TASK-NAME parameter* subtask+
    parameter := PARAM-NAME default-value?
    default-value := string|variable
    variable := VAR-NAME

    # Subtask declarations
    subtask := lhs? command|nested
    command := string
    nested := SUBTASK-NAME argument?
    argument := string
    lhs := VAR-NAME

    # Final
    string := (string-literal|variable-interpolation)+
    variable-interpolation := VAR-NAME
  """


  def parse(self, input):
    tokens = (
      'STRING',
      'VARNAME',
      'COMMENT',
      'TASKNAME',
      'INDENT',
      'COMMAND',
      'WHITESPACE',
      'NEWLINE',
    )

    literals = ":,"

    # TODO: this doesn't allow escaping of strings, nor single-quoted strings.
    t_STRING = r'"[\"]"'

    # Put this before TASKNAME
    def t_COMMAND(t):
      r'\$\s\S[^\n]*(?=\n)' # Starts with '$ ' then a character, and goes to the end of the line.
      t.value = t.value[2:]
      return t

    # A task must flush left, be comprised entirely of lower-case letters and
    # hyphens (no CamelCase allowed), and may optionally start with an
    # upper-case letter to indicate top-level tasks. Underscores are not
    # allowed.
    def t_TASKNAME(t):
      r'[A-Za-z][a-zA-Z0-9\-]*'
      return t

    def t_INDENT(t):
      r'(?<=\n)\ \ (?=\S)' # Exactly 2 spaces, preceeded by a \n, followed by non-whitespace
      t.lexer.lineno += 1
      return t

    # Low priority: Throw away the newlines that aren't indents
    def t_NEWLINE(t):
      r'\n'
      t.lexer.lineno += 1

    # Low priority: Throw away remaining whitespace
    def t_WHITESPACE(t):
      r'\s'
      return t



    def p_file(p):
      """
        file : task_list
      """
      p[0] = ('file', p[1])


    def p_task_list(p):
      """
        task_list : task_list task
                  | empty
      """
      if len(p) == 2:
        p[0] = []
      else:
        p[0] = p[1] + [p[2]]


    def p_empty(p):
      """
        empty :
      """
      pass


    def p_task(p):
      """
        task : TASKNAME ':' subtask_list
      """
      p[0] = ('task', p[1], p[3])


    def p_subtask_list(p):
      """
        subtask_list : subtask_list subtask
                     | empty
      """
      if len(p) == 2:
        p[0] = []
      else:
        p[0] = p[1] + [p[2]]


    def p_subtask(p):
      """
        subtask : INDENT nested_subtasks
                | INDENT command_subtask
      """
      p[0] = p[2]

    def p_nested_subtasks(p):
      """
        nested_subtasks : TASKNAME ',' nested_subtasks
                        | TASKNAME
      """
      if len(p) == 2:
        p[0] = [('subtask', p[1])]
      else:
        p[0] = [('subtask', p[1])] + p[3]


    def p_command_subtask(p):
      """
        command_subtask : COMMAND
      """
      p[0] = ('command', p[1])


    def t_error(p):
      print p
      sys.exit(1)

    def column_number(input, lexpos):
      last_cr = input.rfind('\n', 0, lexpos)
      if last_cr < 0:
        last_cr = 0
      column = (token.lexpos - last_cr) + 1
      return column


    debug = True
    lex.lex(debug=debug)
    parser = yacc.yacc(debug=debug)
    return parser.parse(input, debug=debug)










class Task(object):

  def __init__(self, name):
    self._name = name
    self.subtask_names = []

  def add_subtask(self, subtask_name):
    self.subtask_names += [subtask_name]

  def __str__(self):
    return self._name + str(self.subtask_names)

  def run(self, tasks):
    for subtask_name in self.subtask_names:
      tasks.run_task(subtask_name)



class ShellSubtask(object):
  def __init__(self, command):
    self.command = command

  def run(self, tasks):
    print ("TODO: " + command)


class NestedSubtask(object):
  def __init__(self, name):
    self.name = name

  def run(self, tasks):
    tasks.run_task(self.name)



class Tasks(object):

  def __init__(self):
    self._tasks = {}
    self._top_level_tasks = {}
    self._current_task = None
    self._referenced_tasks = set()

  def add_task(self, line):
    if line [-1] != ':':
      raise Exception("syntax error: each task name must end in ':'")

    name = strs.group(1)
    argstring = strs.group(2)
    # Comma-separated list of NAME=DEFAULT_VALUE

    print name
    print args

    if name in self._tasks:
      raise Exception("Task already exists: " + name)

    task = Task(name)
    self._tasks[name.lower()] = task
    self._current_task = task

    # Top level tasks are id'd by a capital first letter, though they can be accessed without them
    if name[0].isupper():
      self._top_level_tasks[name.lower()] = task

  def add_subtask(self, subtask):
    if self._current_task == None:
      raise Exception("Subtask has no task:" + subtask)

    self._current_task.add_subtask(subtask)

  def add_shell_subtask(self, subtask_string):
    self.add_subtask(ShellSubtask(subtask_string))

  def add_nested_subtask(self, subtask_name):
    self.add_subtask(NestedSubtask(subtask_name))


  def add_parsed_subtasks(self, subtask_string):
    """Hide the line parsing away from the top-level code"""
    s = subtask_string
    if s[0] in ['$']:               # shell tasks
      self.add_shell_subtask(s)
    else:                           # comma or semi-colon separated lists of tasks
      for subtask_name in [string.strip (sep) for sep in string.split(s, ',;')]:
        self._referenced_tasks.add(subtask_name)
        self.add_nested_subtask(subtask_name)


  def check(self):
    """Apply some checks to the structures, make sure everything is OK"""
    for name in self._referenced_tasks:
      if name not in self._tasks:
        raise Exception("Undefined task: " + name)


  def run_top_level_task(self, name):
    if name.lower() not in self._top_level_tasks:
      raise Exception("No top-level task named: " + name)

    self.run_task(name)


  def run_task(self, taskname):
    self._tasks[taskname].run(tasks)

  def top_level_task_list(self):
    return self._top_level_tasks.keys()

  def task_list(self):
    return self._tasks.keys()



def parse_buggery_file():

  # parse line-by-line, building tasks and subtasks as we go.
  current_depth = 0
  tasks = Tasks()
  current_task = None

  for l in file(filename):

    # remove comments
    # TODO: this doesn't allow # to appear anywhere, not even in string literals
    l = string.split(l, '#')[0]

    # expand tabs
    l = string.expandtabs(l, 8)

    # ignore blank lines
    if (string.strip(l) == ""):
      continue

    # remove whitespace, keeping track of the identation ("depth")
    depth = len(l)
    l = string.lstrip(l)
    depth -= len (l)
    l = string.rstrip(l)

    # build the structure
    if depth == 0:
      tasks.add_task(l)
    else:
      tasks.add_parsed_subtasks(l)

  return tasks


#######################
# Command-line options
#######################

def parse_command_line():
  parser = OptionParser()
  parser.add_option(  '-l',
                      '--list',
                      action="store_true",
                      default=False,
                      help="List all top-level tasks",
                   )
  parser.add_option(  '--full-list',
                      action="store_true",
                      default=False,
                      help="List all tasks",
                   )
  parser.add_option(  '-f',
                      '--file',
                      action="store",
                      default=None,
                      type="string",
                      help="Read FILE as a buggery file",
                      dest="FILE",
                   )

  return parser.parse_args(sys.argv)

(options, args) = parse_command_line()

# If no task is given, run default.
if len (args) == 1:
  args[0] = "default"



# Find the buggery file
if options.FILE:
  filename = options.FILE
else:
  filenames = glob.glob("*.buggery")
  if len(filenames) > 1:
    raise WhatToDo("more than one file")
  if len(filenames) == 0:
    raise Error("No .buggery files found")
  filename = filenames[0]
input = file(filename).read()

# Parse the buggery file
parser = Parser()
ast = parser.parse(input)
print ast
sys.exit(1)


##############################################
# Process post-reading command-line options
##############################################
if options.list:
  print ast.top_level_task_list()

if options.full_list:
  print ast.task_list()


##############################################
# Start processing tasks
##############################################

ast.check()

# Always run the startup task
ast.run_top_level_task("startup")
ast.run_top_level_task(task)
