#!/usr/bin/env python

import string
import pprint
import sys
import os
import glob
import re
from optparse import OptionParser # use optparse rather than argparse since it's portable between versions, not just 2.7 and beyond.
from buggery.exceptions import CommandError


try:
  from buggery import Parser
except ImportError, e:
  if str(e) == 'No module named ply.lex' or str(e) == 'No module named ply.yacc':
    sys.exit(
"""PLY (Python Lex-Yacc) library required.

  On ubuntu:
    $ apt-get install python-ply

  Otherwise, download and install from http://www.dabeaz.com/ply/
""")
  raise e


#raise Exception("No top-level task named: " + name)


#######################
# Command-line options
#######################

def parse_command_line():
  parser = OptionParser()
  parser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False)
  return parser.parse_args(sys.argv)


def main():
  (options, args) = parse_command_line()
  filename = args[1] if len(args) > 1 else None
  command  = args[2] if len(args) > 2 else None
  args = args[3:]

  # Parse the buggery file
  if filename == None:
    sys.exit("No filename given")
  input = file(filename).read()
  bugger = Parser().parse(input)
  bugger.options = options

##############################################
# Process post-reading command-line options
##############################################


##############################################
# Start processing tasks
##############################################

  if command == None:
    command = "help"

  if command == "help":
    print bugger.help_string()
    sys.exit(0)

# Always run the startup task
  bugger.run("startup", [], True)
  bugger.run(command, args)


if __name__ == "__main__":
  try:
    main()
  except CommandError, e:
    print """A command has failed:
  command:   %s
  stdin:     %s
  stdout:    '%s'
  stderr:    '%s'
  exit code: %d
  pid:       %d
""" % (e.proc.command, e.proc.stdin, e.proc.stdout, e.proc.stderr, e.proc.exit_code, e.proc.pid)


  # Don't catch UserErrors yet

