#!/usr/bin/env python

import string
import pprint
import sys
import os
import glob
import re
from optparse import OptionParser # use optparse rather than argparse since it's portable between versions, not just 2.7 and beyond.


class Error(Exception):
  pass

class WhatToDo(Exception):
  pass




try:
  import ply.lex as lex
  import ply.yacc as yacc
except ImportError:
  sys.exit("""PLY (Python Lex-Yacc) library required.

  On ubuntu:
    $ apt-get install python-ply

  Otherwise, download and install from http://www.dabeaz.com/ply/
""")


class Parser(object):
  """Generate a nice AST to use later. We can implement the rule running as an AST walker.
  Here are the parser productions, ignoring syntactic tokens:

    # File
    file := task*

    # Task declarations
    task := ID parameter* subtask_line+
    parameter := ID default-value?
    default-value := string|variable
    variable := ID

    # Subtask declarations
    subtask_line := ID? COMMAND|(subtask*)
    subtask := ID argument*
    argument := string|variable

    # Final
    string := (string-literal|variable-interpolation)+
    variable-interpolation := ID

  The AST is slightly nicer:

    # File
    file := task*

    # Task declarations
    task := taskname:ID parameter* subtask+
    parameter := paramname:ID default-value?
    default-value := string|variable
    variable := varname:ID

    # Subtask declarations
    subtask := lvalue:ID? (COMMAND|taskname:ID argument*) # don't like this - move into subtask - but call it something else.
    argument := string|variable
    lvalue := ID

    # Final
    string := (string-literal|variable-interpolation)+
    variable-interpolation := ID

  The AST is implemented as tuples containing the name of the production, followed by the parameters.
  Lists are wrapped in tuples as in: ('param-list' [('param', ...), ('param', ...)])

  """


  def parse(self, input):
    tokens = (
      'STRING',
      'ID',
      'INDENT',
      'COMMAND',
    )

    literals = ":,=()$"

    # TODO: this doesn't allow escaping of strings, nor single-quoted strings.
    def t_STRING(t):
      r'"[^"]*"'
      t.value = ('STRING', t.value)
      return t

    # Put this before TASKNAME
    def t_COMMAND(t):
      r'\$\s\S[^\n]*' # Starts with '$ ' then a character, and goes to the end of the line.
      t.value = t.value[2:]
      t.value = ('COMMAND', t.value)
      return t

    # A task must flush left, be comprised entirely of lower-case letters and
    # hyphens (no CamelCase allowed), and may optionally start with an
    # upper-case letter to indicate top-level tasks. Underscores are not
    # allowed.
    def t_ID(t):
      r'[A-Za-z][a-zA-Z0-9\-]*'
      t.value = ('ID', t.value)
      return t

    def t_INDENT(t):
      r'(?<=\n)\ \ (?=\S)' # Exactly 2 spaces, preceeded by a \n, followed by non-whitespace
      t.lexer.lineno += 1
      return t

    # Low priority: Throw away the newlines that aren't indents
    def t_NEWLINE(t):
      r'\n'
      t.lexer.lineno += 1

    # Throw away remaining whitespace (low priority)
    def t_WHITESPACE(t):
      r'\s'

    # Throw away comments (low priority)
    def t_COMMENT(t):
      r'\#[^\n]*'
      pass




    def p_error(p):
      print p.__dict__
      raise Error()


    def p_file(p):
      """
        file : task_list
      """
      p[0] = ('file', p[1])


    def p_task_list(p):
      """
        task_list : task_list task
                  | empty
      """
      if len(p) == 2:
        p[0] = []
      else:
        p[0] = p[1] + [p[2]]


    def p_empty(p):
      """
        empty :
      """
      pass


    def p_task(p):
      """
        task : ID ':' subtask_lines
             | ID '(' param_list ')' ':' subtask_lines
      """
      name = p[1]
      if len(p) == 4:
        params = []
        subtasks = p[3]
      else:
        params = p[3]
        subtasks = p[6]
      p[0] = ('task', name, ('param-list', params), ('subtask-list', subtasks))
      print ("Completed a task" + str(p[0]))


    def p_subtask_lines(p):
      """
        subtask_lines : subtask_lines subtask_line
                      | empty
      """
      if len(p) == 2:
        p[0] = []
      elif isinstance(p[2], list): # subtask_line can be a subtask_list
        p[0] = p[1] + p[2]
      else:
        p[0] = p[1] + [p[2]]


    # TODO: this is awkward - see if you can move the top 3 to the assignment production.
    def p_subtask_line(p):
      """
        subtask_line : INDENT assignment subtask
                     | INDENT assignment COMMAND
                     | INDENT assignment STRING
                     | INDENT subtask_list
                     | INDENT COMMAND
      """
      if len(p) == 3:
        p[0] = p[2] # same for command or subtask_list

      else:
        p[0] = ('assignment', p[2], p[3])


    def p_assignment(p):
      """
        assignment : ID '='
      """
      if len(p) != 2:
        p[0] = p[1]


    def p_subtask_list(p):
      """
        subtask_list : subtask ',' subtask_list
                     | subtask
      """
      if len(p) == 2:
        p[0] = [p[1]]
      else:
        p[0] = [p[1]] + p[3]

    def p_subtask(p):
      """
        subtask : ID '(' arg_list ')'
                | ID
      """
      if len(p) == 2:
        p[0] = ('subtask', p[1], ('arg-list', []))
      else:
        p[0] = ('subtask', p[1], ('arg-list', p[3]))


    def p_arg_list(p):
      """
        arg_list : arg ',' arg_list
                 | arg
      """
      if len(p) == 2:
        p[0] = [p[1]]
      else:
        p[0] = [p[1]] + p[3]

    def p_arg(p):
      """
        arg : variable
            | STRING
      """
      p[0] = p[1]


    def p_param_list(p):
      """
        param_list : param ',' param_list
                   | param
      """
      if len(p) == 2:
        p[0] = [p[1]]
      else:
        p[0] = [p[1]] + p[3]

    def p_param(p):
      """
        param : ID
              | ID '=' default_param
      """
      p[0] = p[1]

    def p_default_param(p):
      """
        default_param : arg
      """
      p[0] = p[1]




    def p_variable(p):
      """
        variable : '$' ID
      """
      p[0] = ('variable', p[2])




    def t_error(p):
      print p
      sys.exit(1)

    def column_number(input, lexpos):
      last_cr = input.rfind('\n', 0, lexpos)
      if last_cr < 0:
        last_cr = 0
      column = (token.lexpos - last_cr) + 1
      return column


    debug = True
    lex.lex(debug=debug)
    parser = yacc.yacc(debug=debug)
    return parser.parse(input, debug=debug)










class Task(object):

  def __init__(self, name):
    self._name = name
    self.subtask_names = []

  def add_subtask(self, subtask_name):
    self.subtask_names += [subtask_name]

  def __str__(self):
    return self._name + str(self.subtask_names)

  def run(self, tasks):
    for subtask_name in self.subtask_names:
      tasks.run_task(subtask_name)



class ShellSubtask(object):
  def __init__(self, command):
    self.command = command

  def run(self, tasks):
    print ("TODO: " + command)


class NestedSubtask(object):
  def __init__(self, name):
    self.name = name

  def run(self, tasks):
    tasks.run_task(self.name)



class Tasks(object):

  def __init__(self):
    self._tasks = {}
    self._top_level_tasks = {}
    self._current_task = None
    self._referenced_tasks = set()

  def add_task(self, line):
    if line [-1] != ':':
      raise Exception("syntax error: each task name must end in ':'")

    name = strs.group(1)
    argstring = strs.group(2)
    # Comma-separated list of NAME=DEFAULT_VALUE

    print name
    print args

    if name in self._tasks:
      raise Exception("Task already exists: " + name)

    task = Task(name)
    self._tasks[name.lower()] = task
    self._current_task = task

    # Top level tasks are id'd by a capital first letter, though they can be accessed without them
    if name[0].isupper():
      self._top_level_tasks[name.lower()] = task

  def add_subtask(self, subtask):
    if self._current_task == None:
      raise Exception("Subtask has no task:" + subtask)

    self._current_task.add_subtask(subtask)

  def add_shell_subtask(self, subtask_string):
    self.add_subtask(ShellSubtask(subtask_string))

  def add_nested_subtask(self, subtask_name):
    self.add_subtask(NestedSubtask(subtask_name))


  def add_parsed_subtasks(self, subtask_string):
    """Hide the line parsing away from the top-level code"""
    s = subtask_string
    if s[0] in ['$']:               # shell tasks
      self.add_shell_subtask(s)
    else:                           # comma or semi-colon separated lists of tasks
      for subtask_name in [string.strip (sep) for sep in string.split(s, ',;')]:
        self._referenced_tasks.add(subtask_name)
        self.add_nested_subtask(subtask_name)


  def check(self):
    """Apply some checks to the structures, make sure everything is OK"""
    for name in self._referenced_tasks:
      if name not in self._tasks:
        raise Exception("Undefined task: " + name)


  def run_top_level_task(self, name):
    if name.lower() not in self._top_level_tasks:
      raise Exception("No top-level task named: " + name)

    self.run_task(name)


  def run_task(self, taskname):
    self._tasks[taskname].run(tasks)

  def top_level_task_list(self):
    return self._top_level_tasks.keys()

  def task_list(self):
    return self._tasks.keys()



def parse_buggery_file():

  # parse line-by-line, building tasks and subtasks as we go.
  current_depth = 0
  tasks = Tasks()
  current_task = None

  for l in file(filename):

    # remove comments
    # TODO: this doesn't allow # to appear anywhere, not even in string literals
    l = string.split(l, '#')[0]

    # expand tabs
    l = string.expandtabs(l, 8)

    # ignore blank lines
    if (string.strip(l) == ""):
      continue

    # remove whitespace, keeping track of the identation ("depth")
    depth = len(l)
    l = string.lstrip(l)
    depth -= len (l)
    l = string.rstrip(l)

    # build the structure
    if depth == 0:
      tasks.add_task(l)
    else:
      tasks.add_parsed_subtasks(l)

  return tasks


#######################
# Command-line options
#######################

def parse_command_line():
  parser = OptionParser()
  parser.add_option(  '-l',
                      '--list',
                      action="store_true",
                      default=False,
                      help="List all top-level tasks",
                   )
  parser.add_option(  '--full-list',
                      action="store_true",
                      default=False,
                      help="List all tasks",
                   )
  parser.add_option(  '-f',
                      '--file',
                      action="store",
                      default=None,
                      type="string",
                      help="Read FILE as a buggery file",
                      dest="FILE",
                   )

  return parser.parse_args(sys.argv)

(options, args) = parse_command_line()

# If no task is given, run default.
if len (args) == 1:
  args[0] = "default"



# Find the buggery file
if options.FILE:
  filename = options.FILE
else:
  filenames = glob.glob("*.buggery")
  if len(filenames) > 1:
    raise WhatToDo("more than one file")
  if len(filenames) == 0:
    raise Error("No .buggery files found")
  filename = filenames[0]
  print "Running %s" % filename
input = file(filename).read()

# Parse the buggery file
parser = Parser()
ast = parser.parse(input)
print pprint.pprint(ast)
sys.exit(1)


##############################################
# Process post-reading command-line options
##############################################
if options.list:
  print ast.top_level_task_list()

if options.full_list:
  print ast.task_list()


##############################################
# Start processing tasks
##############################################

ast.check()

# Always run the startup task
ast.run_top_level_task("startup")
ast.run_top_level_task(task)
