#!/usr/bin/env python

import string
import pprint
import sys
from optparse import OptionParser # use optparse rather than argparse since it's more portable.

# TODO: search up the hierarchy to find the first buggy file
# TODO: keep processing buggery files as you go up the hierarchy?
# Allow calling python functions.
# Define what operations result in what type
# Pattern matching instead of conditionals
# Checkpointing for lazy processing and saving time. Perhaps make notes of functions which can be checkpointed.
# Parallel processing. Perhaps files use semi-colons to separate files which can't be parallelized, instead of commas

"""
Buggery tutorial:
---------------------------


Buggery refe

How to write a buggery file:
-----------------------------


A buggery file is comprised of a long list of tasks.  A task is written::

  Task:
    list
    of
    subtasks

That is, to define a task, write its name with no indentation before it, then a ':'.  Top-level tasks start with a capital letter, may be called from the command line by running 'bugger TASKNAME', where TASKNAME is the name of the task you want to run. At program startup, the rule 'startup' is always called.

Each task is made up of a list of subtasks.  There are a few kinds of subtask:
  - a command subtask
  - a nested subtask

A nested subtask is simple, it just calls another task. It can have a parameter, and you may specify a list of them on the same line, separating them by commas.

A command subtask calls the shell with the given string.

Variables are also allowed. Save a result into a variable using any of::

  VARNAME=$ command # Returns the string output of calling `command`
  VARNAME="some string"

You can use variables in any other place using string-interpolation::

  $ make -f $MAKEFILE

Tasks have parameters, which should always have a default value! The default value will be used it is called without arguments.

Comments start with #, and have the bug that they cannot be escaped in the buggery file.

Any shell command which fails throws an exception, and does not continue. However, it may often be necessary to clean up your state. The can be done by adding multiple levels of nesting. TODO. Any level above that level will still be executed. This should only be used to clean up.

In general, any rule should end up with the same rough state. I may ammend that to say that rules may start with ! in order to signal that they are destructive.


  Coming features:
    - saving work will be supported (either checkpointing or making notes)
    - it uses a line parser, which is dodgy around strings, commas, dollars, equals, etc.

"""





#setup_command_line()

class Task(object):

  def __init__(self, name):
    self._name = name
    self.subtask_names = []

  def add_subtask(self, subtask_name):
    self.subtask_names += [subtask_name]

  def __str__(self):
    return self._name + str(self.subtask_names)

  def run(self, tasks):
    for subtask_name in self.subtask_names:
      tasks.run_task(subtask_name)



class ShellSubtask(object):
  def __init__(self, command):
    self.command = command

  def run(self, tasks):
    print ("TODO: " + command)


class NestedSubtask(object):
  def __init__(self, name):
    self.name = name

  def run(self, tasks):
    tasks.run_task(self.name)



class Tasks(object):

  def __init__(self):
    self._tasks = {}
    self._top_level_tasks = {}
    self._current_task = None
    self._referenced_tasks = set()

  def add_task(self, name):
    if name[-1] != ':':
      raise Exception("syntax error: each task name must end in ':'")

    name = name[:-1]
    if name in self._tasks:
      raise Exception("Task already exists: " + name)

    task = Task(name)
    self._tasks[name.lower()] = task
    self._current_task = task

    # Top level tasks are id'd by a capital first letter, though they can be accessed without them
    if name[0].isupper():
      self._top_level_tasks[name.lower()] = task

  def add_subtask(self, subtask):
    if self._current_task == None:
      raise Exception("Subtask has no task:" + subtask)

    self._current_task.add_subtask(subtask)

  def add_shell_subtask(self, subtask_string):
    self.add_subtask(ShellSubtask(subtask_string))

  def add_nested_subtask(self, subtask_name):
    self.add_subtask(NestedSubtask(subtask_name))


  def add_parsed_subtasks(self, subtask_string):
    """Hide the line parsing away from the top-level code"""
    s = subtask_string
    if s[0] in ['$']:               # shell tasks
      self.add_shell_subtask(s)
    else:                           # comma separated lists of tasks
      for subtask_name in [string.strip (sep) for sep in string.split(s, ',')]:
        self._referenced_tasks.add(subtask_name)
        self.add_nested_subtask(subtask_name)


  def check(self):
    """Apply some checks to the structures, make sure everything is OK"""
    for name in self._referenced_tasks:
      if name not in self._tasks:
        raise Exception("Undefined task: " + name)


  def run_top_level_task(self, name):
    if name.lower() not in self._top_level_tasks:
      raise Exception("No top-level task named: " + name)

    self.run_task(name)


  def run_task(self, taskname):
    self._tasks[taskname].run(tasks)

  def top_level_task_list(self):
    return self._top_level_tasks.keys()

  def task_list(self):
    return self._tasks.keys()



def parse_buggery_file():

  # parse line-by-line, building tasks and subtasks as we go.
  current_depth = 0
  tasks = Tasks()
  current_task = None

  for l in file("buggery"):

    # remove comments
    # TODO: this doesn't allow # to appear anywhere, not even in string literals
    l = string.split(l, '#')[0]

    # expand tabs
    l = string.expandtabs(l, 8)

    # ignore blank lines
    if (string.strip(l) == ""):
      continue

    # remove whitespace, keeping track of the identation ("depth")
    depth = len(l)
    l = string.lstrip(l)
    depth -= len (l)
    l = string.rstrip(l)

    # build the structure
    if depth == 0:
      tasks.add_task(l)
    else:
      tasks.add_parsed_subtasks(l)

  return tasks


#######################
# Command-line options
#######################

parser = OptionParser()
parser.add_option(  '-l',
                    '--list',
                    action="store_true",
                    default=False,
                    help="List all top-level tasks",
                 )
parser.add_option(  '--full-list',
                    action="store_true",
                    default=False,
                    help="List all tasks",
                 )
(options, args) = parser.parse_args(sys.argv)

# If no task is given, run default.
if len (args) == 1:
  args[0] = "default"



# Read and check the file
tasks = parse_buggery_file()


##############################################
# Process post-reading command-line options
##############################################
if options.list:
  print tasks.top_level_task_list()

if options.full_list:
  print tasks.task_list()


##############################################
# Start processing tasks
##############################################

tasks.check()

# Always run the startup task
tasks.run_top_level_task("startup")
tasks.run_top_level_task(task)
