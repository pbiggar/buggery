#!/usr/bin/env python

import string
import pprint
import sys
import os
import glob
from optparse import OptionParser # use optparse rather than argparse since it's portable between versions, not just 2.7 and beyond.

class Error(Exception):
  pass

class WhatToDo(Exception):
  pass



class Task(object):

  def __init__(self, name):
    self._name = name
    self.subtask_names = []

  def add_subtask(self, subtask_name):
    self.subtask_names += [subtask_name]

  def __str__(self):
    return self._name + str(self.subtask_names)

  def run(self, tasks):
    for subtask_name in self.subtask_names:
      tasks.run_task(subtask_name)



class ShellSubtask(object):
  def __init__(self, command):
    self.command = command

  def run(self, tasks):
    print ("TODO: " + command)


class NestedSubtask(object):
  def __init__(self, name):
    self.name = name

  def run(self, tasks):
    tasks.run_task(self.name)



class Tasks(object):

  def __init__(self):
    self._tasks = {}
    self._top_level_tasks = {}
    self._current_task = None
    self._referenced_tasks = set()

  def add_task(self, name):
    if name[-1] != ':':
      raise Exception("syntax error: each task name must end in ':'")

    name = name[:-1]
    if name in self._tasks:
      raise Exception("Task already exists: " + name)

    task = Task(name)
    self._tasks[name.lower()] = task
    self._current_task = task

    # Top level tasks are id'd by a capital first letter, though they can be accessed without them
    if name[0].isupper():
      self._top_level_tasks[name.lower()] = task

  def add_subtask(self, subtask):
    if self._current_task == None:
      raise Exception("Subtask has no task:" + subtask)

    self._current_task.add_subtask(subtask)

  def add_shell_subtask(self, subtask_string):
    self.add_subtask(ShellSubtask(subtask_string))

  def add_nested_subtask(self, subtask_name):
    self.add_subtask(NestedSubtask(subtask_name))


  def add_parsed_subtasks(self, subtask_string):
    """Hide the line parsing away from the top-level code"""
    s = subtask_string
    if s[0] in ['$']:               # shell tasks
      self.add_shell_subtask(s)
    else:                           # comma or semi-colon separated lists of tasks
      for subtask_name in [string.strip (sep) for sep in string.split(s, ',;')]:
        self._referenced_tasks.add(subtask_name)
        self.add_nested_subtask(subtask_name)


  def check(self):
    """Apply some checks to the structures, make sure everything is OK"""
    for name in self._referenced_tasks:
      if name not in self._tasks:
        raise Exception("Undefined task: " + name)


  def run_top_level_task(self, name):
    if name.lower() not in self._top_level_tasks:
      raise Exception("No top-level task named: " + name)

    self.run_task(name)


  def run_task(self, taskname):
    self._tasks[taskname].run(tasks)

  def top_level_task_list(self):
    return self._top_level_tasks.keys()

  def task_list(self):
    return self._tasks.keys()



def parse_buggery_file():

  # parse line-by-line, building tasks and subtasks as we go.
  current_depth = 0
  tasks = Tasks()
  current_task = None

  # Find the buggery file
  filenames = glob.glob("*.buggery")
  if len(filenames) > 1:
    raise WhatToDo("more than one file")
  if len(filenames) == 0:
    raise Error("No .buggery files found")
  filename = filenames[0]


  for l in file(filename):

    # remove comments
    # TODO: this doesn't allow # to appear anywhere, not even in string literals
    l = string.split(l, '#')[0]

    # expand tabs
    l = string.expandtabs(l, 8)

    # ignore blank lines
    if (string.strip(l) == ""):
      continue

    # remove whitespace, keeping track of the identation ("depth")
    depth = len(l)
    l = string.lstrip(l)
    depth -= len (l)
    l = string.rstrip(l)

    # build the structure
    if depth == 0:
      tasks.add_task(l)
    else:
      tasks.add_parsed_subtasks(l)

  return tasks


#######################
# Command-line options
#######################

parser = OptionParser()
parser.add_option(  '-l',
                    '--list',
                    action="store_true",
                    default=False,
                    help="List all top-level tasks",
                 )
parser.add_option(  '--full-list',
                    action="store_true",
                    default=False,
                    help="List all tasks",
                 )
(options, args) = parser.parse_args(sys.argv)

# If no task is given, run default.
if len (args) == 1:
  args[0] = "default"



# Read and check the file
tasks = parse_buggery_file()


##############################################
# Process post-reading command-line options
##############################################
if options.list:
  print tasks.top_level_task_list()

if options.full_list:
  print tasks.task_list()


##############################################
# Start processing tasks
##############################################

tasks.check()

# Always run the startup task
tasks.run_top_level_task("startup")
tasks.run_top_level_task(task)
